/*
 * Copyright 2024 Daniel C. Brotsky. All rights reserved.
 * All the copyrighted work in this repository is licensed under the
 * GNU Affero General Public License v3, reproduced in the LICENSE file.
 */
package tracker

import (
	"regexp"
	"strconv"
	"time"
)

var (
	regexMap = map[string]*regexp.Regexp{
		"line":   regexp.MustCompile(`SessionID=([^.]+\.([0-9]+)) Timestamp=([^ ]+) .*Description="(.+)"`),
		"os":     regexp.MustCompile(`SetConfig:.+OS Name=([^\s,]+), OS Version=([^\s,]+)`),
		"app":    regexp.MustCompile(`SetConfig:.+AppID=([^,]+), AppVersion=([^\s,]+)`),
		"ngl":    regexp.MustCompile(`SetConfig:.+NGLLibVersion=([^\s,]+)`),
		"locale": regexp.MustCompile(`SetAppRuntimeConfig:.+AppLocale=([^\s,]+)`),
		"user":   regexp.MustCompile(`LogCurrentUser:.+UserID=([^\s,]+)`),
	}
)

// A logSession captures the information from a single log about
// a single launch of a single application.
//
// The sessionId is generated by the app and is unique to the launch.
// Although a single launch of a single application may generate more
// than one log, the session_id will be the same for all of them.
//
// The launchTime is taken from the last component of the
// sessionId, which by Adobe convention is the launch time of the
// app. This ensures that the launchTime is the same for all logs
// generated from the same launch.
//
// The launchDuration field measures the time between the last
// log line of the session and the launch time of the session.
// If a session's log gets split among multiple log files, this
// means that later files will create sessions with bigger
// launchDuration times.
type logSession struct {
	sessionId      string
	launchTime     time.Time
	launchDuration time.Duration
	appId          string // NGL app ID
	appVersion     string
	appLocale      string
	nglVersion     string // version of the app's NGL library
	osName         string
	osVersion      string
	userId         string // a SHA1 of the logged-in Adobe user ID
}

// parseLog reads every line of a log's contents, and returns
// a slice of the logSessions found in the log.  It never fails,
// but it will return an empty slice on malformed input.
func parseLog(log string) (sessions []logSession) {
	var session logSession
	var lastTime time.Time
	endSession := func() {
		if session.sessionId != "" {
			if lastTime.Compare(session.launchTime) > 0 {
				session.launchDuration = lastTime.Sub(session.launchTime)
			}
			sessions = append(sessions, session)
		}
	}
	for _, line := range regexMap["line"].FindAllStringSubmatch(log, -1) {
		if sessionId := line[1]; sessionId != session.sessionId {
			endSession()
			session = logSession{sessionId: sessionId, launchTime: parseTimeMillis(line[2])}
		}
		lastTime = parseLogTimestamp(line[3])
		parseLogDescription(line[4], &session)
	}
	endSession()
	return
}

// parseLogDescription takes the description field of a log line and
// fills session parameters from values found in the description.
func parseLogDescription(description string, session *logSession) {
	var match []string
	if match = regexMap["os"].FindStringSubmatch(description); match != nil {
		session.osName = match[1]
		session.osVersion = match[2]
	} else if match = regexMap["app"].FindStringSubmatch(description); match != nil {
		session.appId = match[1]
		session.appVersion = match[2]
	} else if match = regexMap["ngl"].FindStringSubmatch(description); match != nil {
		session.nglVersion = match[1]
	} else if match = regexMap["locale"].FindStringSubmatch(description); match != nil {
		session.appLocale = match[1]
	} else if match = regexMap["user"].FindStringSubmatch(description); match != nil {
		session.userId = match[1]
	}
}

// parseTimeMillis is given a string representing a number of
// milliseconds since the Unix Epoch and returns a time.Time
// containing that value. If it's given malformed input, it
// returns the epoch.
func parseTimeMillis(s string) time.Time {
	msec, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		return time.UnixMilli(0)
	}
	return time.UnixMilli(msec)
}

// parseLogTiimestamp is given a date string in the unique format
// written by Adobe apps in their log, and returns a time.Time
// containing that value. If it's given malformed input, it
// returns the epoch.
func parseLogTimestamp(s string) time.Time {
	// incoming format is "2024-02-15T10:54:21:732-0800"
	// but we have to replace that last : with a . to get it to parse.
	// Luckily, it's at a fixed offset in the timestring
	if s[19] != ':' {
		return time.UnixMilli(0)
	}
	valid := s[0:19] + "." + s[20:]
	t, err := time.Parse("2006-01-02T15:04:05.999-0700", valid)
	if err != nil {
		return time.UnixMilli(0)
	}
	return t
}
